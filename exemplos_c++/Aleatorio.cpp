/* * Robot: Aleatorio *  * Movimenta-se aleatóriamente pelo campo de batalha. */#include "port_module.h"class Aleatorio : public Robot {	public:		Aleatorio();		~Aleatorio();		void start();		private:		// Enquanto true o robô continua a funcionar		bool alive;		// Controla a direcção do movimento do robô		int moving;		void round_started( int args );		void on_hit_wall( string wall );		void on_hit_robot( OnHitRobotEvent event );};Aleatorio::Aleatorio() {	alive = true;	moving = 1;	// Inicia o robô	init();}Aleatorio::~Aleatorio(){}void Aleatorio::round_started( int args ) {	stringstream ss;	ss << args;	cout << "round_started( " + ss.str() +  " )" << endl;	moving = 1;	exec_mode( "block" );	subscribe_events( "[on_hit_robot, on_hit_wall]" );}void Aleatorio::on_hit_wall( string wall ) {	cout << "on_hit_wall( " + wall + " )" << endl;	moving *= -1;}void Aleatorio::on_hit_robot( OnHitRobotEvent event ) {	cout << "#################################" << endl;	cout << "on_hit_robot()" << endl;	cout << event.robotName << endl;	cout << event.robotDamage << endl;	cout << "[";	for ( int i = 0; i < event.robotArmor.size(); i++ ) {		cout << " " << event.robotArmor[i];	}	cout << " ]" << endl;	cout << event.relativeDirection << endl;	cout << "#################################" << endl;	moving *= -1;}void Aleatorio::start() {	while ( alive ) {		robot_move_forward( 300 * moving );		robot_turn_right( 90 );		execute();	}}int main() {	Aleatorio robot;	robot.start();	return 0;}