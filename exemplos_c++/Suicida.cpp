/* * Robot: Suicida *  * Procura inimigos com o radar e vai contra o primeiro que encontrar ate não ter energia. */#include "port_module.h"class Suicida : public Robot {	public:		Suicida();		~Suicida();		void start();		private:		// Enquanto true o robô continua a funcionar		bool alive;		bool _hitWall;		// Vector com os objectos encontrados durante o rastreio		vector<ObjClass> _targets;			void round_started( int args );		void on_hit_wall( string wall );		void out_of_energy();		void scan_event( ScanEvent event );};Suicida::Suicida() {	alive = true;	_hitWall = false;	// Inicia o robô	init();}Suicida::~Suicida(){}void Suicida::round_started( int args ) {	stringstream ss;	ss << args;	cout << "round_started( " + ss.str() +  " )" << endl;	exec_mode( "block" );	subscribe_events( "[on_hit_wall,out_of_energy,scan_event]" );}void Suicida::on_hit_wall( string wall ) {	cout << "on_hit_wall( " + wall + " )" << endl;	_hitWall = true;}void Suicida::out_of_energy() {	cout << "out_of_energy()" << endl;	// Faz uma pausa para recarregar as baterias ate conseguir andar novamente	sleep(2);	// Reduz a velocidade para reduzir o consumo de energia	set_speed( 2 );	execute();}void Suicida::scan_event( ScanEvent event ) {	_targets.clear();	int counter = 0;	cout << "#################################" << endl;	for ( int i = 0; i < event.count(); i++ ) {		cout << "- Alvo ";		cout << counter;		cout << " :" << endl;		ObjClass obj = event.objsList.at(i);		cout << obj.objName << endl;		cout << obj.objEnergy << endl;		cout << obj.objDamage << endl;		cout << "[";		for ( int i = 0; i < obj.objArmor.size(); i++ )			cout << " " << obj.objArmor[i];		cout << " ]" << endl;		cout << "[";		for ( int i = 0; i < obj.objPosition.size(); i++ )			cout << " " << obj.objPosition[i];		cout << " ]" << endl;		cout << obj.objDirection << endl;		cout << obj.objRelativeDirection << endl;		cout << obj.objSpeed << endl;		cout << obj.objDistance << endl;		_targets.push_back( obj );		counter += 1;		cout << "#################################" << endl;	}}void Suicida::start() {	int direction = 0;	int halfDist = 0;	while ( alive ) {		scan();		execute();		if ( !_targets.empty() ) {			// Ataca o primeiro alvo encontrado			ObjClass target = _targets.at(0);			// Direcciona-se parar o inimigo			robot_turn_to( target.objRelativeDirection );			// Vai-se aproximando gradualmente			halfDist = ( target.objDistance / 2 );			// Se estiver a bater numa parede não anda para a frente			if ( _hitWall == true ) {				_hitWall = false;				robot_move_backward( halfDist );			}			else				robot_move_forward( halfDist );			execute();		}	}}int main() {	Suicida robot;	robot.start();	return 0;}